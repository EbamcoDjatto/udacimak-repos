{
  "data": {
    "lesson": {
      "id": 653246,
      "key": "59930ed5-6f24-4cd2-bf0a-c0a0075cd7b4",
      "title": "Use a Pre-trained Image Classifier to Identify Dog Breeds",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": null,
      "lesson_type": "Classroom",
      "display_workspace_project_only": false,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/59930ed5-6f24-4cd2-bf0a-c0a0075cd7b4/653246/1544038122838/Use+a+Pre-trained+Image+Classifier+to+Identify+Dog+Breeds+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/59930ed5-6f24-4cd2-bf0a-c0a0075cd7b4/653246/1544038120285/Use+a+Pre-trained+Image+Classifier+to+Identify+Dog+Breeds+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": {
        "key": "554c4f60-32dc-42c7-882f-9c9fb7eb901d",
        "version": "1.0.0",
        "locale": "en-us",
        "duration": 40320,
        "semantic_type": "Project",
        "title": "Use a Pre-trained Image Classifier to Identify Dog Breeds",
        "description": "# Submitting the Project\n\n\n## I'm Ready!\n\nWhen you are ready to submit your project, There are three ways in which your project can be submitted for evaluation.\n\n1. The easiest way to submit is If you worked using the workspace inside the classroom you can submit your project directly for review using the submit button at the end of project.\n\n2. If you ran the notebook from your local machine compress all files into a single file and you can upload the file.\n\n3. You could supply the above files on your GitHub Repo and share the link. This would build a good Github profile in parallel.\n\n## What's Next?\n\nYou will get an email as soon as your reviewer has feedback for you. In the meantime, review your next project and feel free to get started on it or the courses supporting it!\n\n## Project Submission Checklist\n\n**Before submitting your project, please review and confirm the following items.** \n<input type=\"checkbox\"> I am confident all rubric items have been met and my project will pass as submitted. \n<input type=\"checkbox\"> Project builds correctly without errors and runs.\n<input type=\"checkbox\"> All required functionality exists and my project behaves as expected per the project's specifications.\n\n**Once you have checked all these items, you are ready to submit!**\n",
        "is_public": true,
        "summary": null,
        "forum_path": "",
        "rubric_id": "2150",
        "terminal_project_id": null,
        "resources": null,
        "image": null
      },
      "lab": null,
      "concepts": [
        {
          "id": 568657,
          "key": "933e74b1-aa1b-4de7-a66e-e569745e72ba",
          "title": "Instructor",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "933e74b1-aa1b-4de7-a66e-e569745e72ba",
            "completed_at": "2020-03-26T19:59:19.902Z",
            "last_viewed_at": "2020-03-26T19:59:20.169Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 568658,
              "key": "bf95d5e0-11a2-44f3-be59-385a72afcb67",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5ab02e20_screen-shot-2018-03-19-at-2.39.10-pm/screen-shot-2018-03-19-at-2.39.10-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/bf95d5e0-11a2-44f3-be59-385a72afcb67",
              "caption": "_Jennifer Staab_",
              "alt": "",
              "width": 330,
              "height": 290,
              "instructor_notes": null
            },
            {
              "id": 568659,
              "key": "5b9bb3b2-f0ab-4b0a-9a6a-e90c523dbea0",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "After learning all about Python, we will now start our first lab which will check the coding skills you just gained!\n\nThe lab will be given by Jennifer, a statistician and computer scientist who previously worked as a professor at Florida Polytechnic University.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 653255,
          "key": "0e6d29e9-c65c-4a6c-b65f-689aaa0e311d",
          "title": "Project Description",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "0e6d29e9-c65c-4a6c-b65f-689aaa0e311d",
            "completed_at": "2020-03-26T19:59:35.469Z",
            "last_viewed_at": "2020-04-15T05:10:41.124Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 653256,
              "key": "b53f3d79-4867-456e-a0f6-6754983358c6",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Image Classification for a City Dog Show\n\n\n",
              "instructor_notes": ""
            },
            {
              "id": 662687,
              "key": "ab927bdc-5250-4182-b1ca-2b04da283d1d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Project Goal\n- Improving your *programming* skills using ```Python```\n\n\n",
              "instructor_notes": ""
            },
            {
              "id": 662689,
              "key": "d2ec3800-f5b6-4b56-8115-2326e7acc91d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In this project you will use a *created* image classifier to identify dog breeds. We ask you to focus on *Python* and not on the actual classifier (We will focus on building a classifier ourselves later in the program).",
              "instructor_notes": ""
            },
            {
              "id": 653266,
              "key": "950496d3-90f7-4afb-9342-79b236a62cc5",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## **Description**:\nYour city is hosting a citywide dog show and you have volunteered to help the organizing committee with contestant registration.  Every participant that registers must submit an image of their dog along with biographical information about their dog. The registration system tags the images based upon the biographical information. \n\nSome people are planning on registering pets that **arenâ€™t actual dogs**.\n\nYou need to use an already developed ***```Python``` classifier*** to make sure the participants are dogs.\n\n**Note, you DO NOT need to create the classifier. It will be provided to you. You will need to apply the Python tools you just learned to USE the classifier**.",
              "instructor_notes": ""
            },
            {
              "id": 662686,
              "key": "931c2319-c5c4-4bd4-8a5d-2963a3f40091",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## ** Your Tasks:**\n-  Using your ***```Python``` skills***, you will determine which image classification algorithm works the \"**best**\" on classifying images as \"dogs\" or \"**not** dogs\".\n\n\n- Determine how well the \"**best**\" classification algorithm works on correctly identifying a dog's breed.  \nIf you are confused by the term *image classifier* look at it simply as a tool that has an input and an output. The Input is an image. The output determines what the image depicts.  (for example: a dog). Be mindful of the fact that image classifiers do not always categorize the images correctly. (We will get to all those details much later on the program).\n\n\n- Time how long each algorithm takes to solve the classification problem.\n  With computational tasks, there is often a trade-off between accuracy and runtime. The more accurate an algorithm, the higher the likelihood that it will take more time to run and use more computational resources to run. \n\n\nFor further clarifications, please check our [FAQs](https://github.com/udacity/AIPND-revision/blob/master/notes/project_intro-to-python.md) here. ",
              "instructor_notes": ""
            },
            {
              "id": 653270,
              "key": "0324b2fc-423c-45eb-a835-da73872b8876",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## **Important Notes:**\nFor this image classification task you will be using an image classification application using a deep learning model called a convolutional neural network (often abbreviated as CNN). CNNs work particularly well for detecting features in images like colors, textures, and edges; then using these features to identify objects in the images. You'll use a CNN that has already *learned* the features from a giant dataset of 1.2 million images called [ImageNet](http://www.image-net.org/).  There are different types of CNNs that have different structures (architectures) that work better or worse depending on your criteria.  With this project you'll explore the three different architectures (**AlexNet**, **VGG**,  and **ResNet**) and determine which is best for your application.  \n\nWe have provided you with a *** classifier function*** in ```classifier.py``` that will allow you to use these CNNs to classify your images. The ```test_classifier.py``` file contains an example program that demonstrates how to use the ***classifier function***.  For this project, you will be focusing on using your Python skills to complete these tasks using the ***classifier function***; in the Neural Networks lesson you will be learning more about how these algorithms work.\n \nRemember that certain breeds of dog look very similar.  The more images of two similar looking dog breeds that the algorithm has *learned* from, the more likely the algorithm will be able to distinguish between those two breeds.   We have found the following breeds to look very similar: [Great Pyrenees](https://www.google.com/search?q=Great+Pyrenees&source=lnms&tbm=isch&sa=X&ved=0ahUKEwje252-kpfZAhVF3FMKHeXwB3IQ_AUICigB&biw=1112&bih=1069) and [Kuvasz](https://www.google.com/search?tbm=isch&q=Kuvasz&spell=1&sa=X&ved=0ahUKEwi9_9fTkpfZAhWB7FMKHXlKDWoQBQg6KAA&biw=1112&bih=1069&dpr=1), [German Shepherd](https://www.google.com/search?biw=1112&bih=1069&tbm=isch&sa=1&ei=d7F8WpaaMc_VzgLW8LvABw&q=German+Shepherd&oq=German+Shepherd&gs_l=psy-ab.3..0i67k1j0l2j0i67k1j0l6.31751.41069.0.41515.29.18.4.7.9.0.131.1164.14j2.17.0....0...1c.1.64.psy-ab..2.26.1140.0..0i10k1j0i13k1.112.xUB8_AoVF9w) and [Malinois](https://www.google.com/search?biw=1112&bih=1069&tbm=isch&sa=1&ei=orF8WtHWDcOdzwLnyLXgBw&q=Malinois&oq=Malinois&gs_l=psy-ab.3..0l3j0i67k1l3j0l2j0i67k1j0.31864.42125.0.42493.23.20.0.1.1.0.132.1460.14j4.19.0....0...1c.1.64.psy-ab..8.14.926.0...75.U5aOu6JZ9Vk), [Beagle](https://www.google.com/search?biw=1112&bih=1069&tbm=isch&sa=1&ei=zbF8WqTiHZDxzgKlm5SYBw&q=Beagle&oq=Beagle&gs_l=psy-ab.3..0i67k1j0l2j0i67k1l2j0l5.29396.33482.0.34041.12.8.3.1.1.0.126.585.6j2.8.0....0...1c.1.64.psy-ab..0.12.609...0i10k1.0.Dr92CW2Kqqo) and [Walker Hound](https://www.google.com/search?biw=1112&bih=1069&tbm=isch&sa=1&ei=8LF8WteAGND0zgKvlL-IBw&q=Walker+hound&oq=Walker+hound&gs_l=psy-ab.3..0l10.20697.23454.0.23773.12.10.0.2.2.0.81.601.10.10.0....0...1c.1.64.psy-ab..0.12.610...0i67k1.0.GI0QxI1sadY), amongst others. \n\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 654101,
          "key": "7d660236-c4d5-4db6-892b-96c222195b8a",
          "title": "Project Instructions",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "7d660236-c4d5-4db6-892b-96c222195b8a",
            "completed_at": "2020-03-26T20:03:28.438Z",
            "last_viewed_at": "2020-04-15T05:15:30.070Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 654102,
              "key": "0b1a64f3-39b8-471c-b598-c19df132890b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# **Project Instructions**\n\n",
              "instructor_notes": ""
            },
            {
              "id": 654105,
              "key": "d7531d0d-3062-4a8e-8257-49dcc98b2565",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## **Principal Objectives**\n1. Correctly identify which pet images are of dogs (even if breed is misclassified) and which pet images aren't of dogs.  \n&nbsp;\n2. Correctly classify the breed of dog, for the images that are of dogs.   \n&nbsp;\n3. Determine which CNN model architecture (ResNet, AlexNet, or VGG), \"__best__\" achieve the objectives *1* and *2*.   \n&nbsp;\n4. Consider the *time* resources required to best achieve objectives *1* and *2*, and determine if an alternative solution would have given a \"_good enough_\" result, given the amount of time each of the algorithms take to run.\n",
              "instructor_notes": ""
            },
            {
              "id": 654106,
              "key": "c6bf7ef5-f90a-441c-be80-0f0fd78cfddb",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## **TODO:**\n\n###  Edit program ***```check_images.py```***\n\n\nThe ***```check_images.py```*** is the program file that you will be editing to achieve the four objectives above. This file contains a ```main()``` function that outlines how to complete this program through using functions that have ***not*** yet been defined.  You will be creating these _undefined_ functions in **check_images.py** to achieve the objectives above. \n\nAll of the ```TODOs``` are listed in ```check_images.py```. You will find further elaborations and explanations for each, in the following concepts of this project.\n\n",
              "instructor_notes": ""
            },
            {
              "id": 675835,
              "key": "446170fb-2acf-41cf-89c3-aeeb1defa83a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## **If you feel that you need more guidance, please refer to the files ending with``` _hints.py```.  In the workspace you will find a hint file for each of the tasks.**\n",
              "instructor_notes": ""
            },
            {
              "id": 675836,
              "key": "3f28018b-6ba6-47c3-a142-999b096a5e99",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### **Important notes:**\n\n- Before beginning the project please review the [Frequently Asked Questions](https://github.com/udacity/AIPND-revision/blob/master/notes/project_intro-to-python.md), FAQ, about the project. \n\n\n- This project and other lessons within the Nanodegree will be using a [GitHub repository](https://github.com/udacity/AIPND-revision) to store program files and other resources for this Nanodegree. To learn more about GitHub, please see the **GitHub** Lesson that's located within the **Extracurricular**  (optional) section of this Nanodegree.  \n\n\n-  The **Project Workspace** is set up with the programs and files (like pet_images folder) you will need to complete the project.\n\n\n- The Python comments that begin with ***```# TODO:```*** in the **check_images.py**  program indicates where you will need to change the code of the program.  The comments in **check_images.py** will help you make the changes needed. \n\n\n- Function docstrings contain input ***parameters*** and ***return values***, which were left to provide guidance. You are welcome to program these functions differently.\n\n\n- In **6. Timing Code** to **19. Printing Results** we will provide additional guidance for programming the _undefined_ functions and completing the **check_images.py** program. This information has been provided to help you through the process.  \n\n The information provides:\n - Which **Lessons** to review regarding programming the _undefined_ functions.\n - Details about the assignment's files (e.g. image files in pet_images folder, dognames.txt).\n - Details regarding using the _classifier function_ in **classifier.py**.\n - Links to relevant python documentation.\n - Relevant *example code*. \n\n- You can use the functions within the program [print_functions_for_lab_checks.py](https://github.com/udacity/AIPND-revision/blob/master/intropyproject-classify-pet-images/print_functions_for_lab_checks.py) to check your code for sections **8. Command Line Arguments** through **17. Calculating Results**. You will find this program within the Project Workspace and within the  [GitHub repository](https://github.com/udacity/AIPND-revision). \n",
              "instructor_notes": ""
            },
            {
              "id": 654107,
              "key": "440bd96a-da59-46fb-a2f6-a389d94dec66",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## Program Outline\n\n- Time your program\n - Use Time Module to compute program runtime\n- Get program Inputs from the user\n - Use command line arguments to get user inputs\n- Create Pet Images Labels\n - Use the pet images filenames to create labels\n - Store the pet image labels in a data structure (e.g. dictionary)\n- Create Classifier Labels and Compare Labels\n - Use the *Classifier* function to classify the images and create the classifier labels\n - Compare Classifier Labels to Pet Image Labels\n - Store Pet Labels, Classifier Labels, and their comparison in a complex data structure (e.g. dictionary of lists)\n- Classifying Labels as \"Dogs\" or \"Not Dogs\"\n - Classify all Labels as \"Dogs\" or \"Not Dogs\" using dognames.txt file\n - Store new classifications in the complex data structure (e.g. dictionary of lists)\n- Calculate the Results\n - Use Labels and their classifications to determine how well the algorithm worked on classifying images\n- Print the Results\n\nYou will need to repeat these tasks for each of the three image classification algorithms that are provided to you. \n\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 654110,
          "key": "62a76b66-4288-4883-9099-1c178aef9586",
          "title": "Workspace How-to",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "62a76b66-4288-4883-9099-1c178aef9586",
            "completed_at": "2020-03-26T20:03:59.423Z",
            "last_viewed_at": "2020-04-15T05:16:49.836Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 654112,
              "key": "9ffe47a4-122f-49b4-8043-35cf8bb9969e",
              "title": "AIPND Python Lab - Workspace How-to Video",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "EQTttywUnXQ",
                "china_cdn_id": "EQTttywUnXQ.mp4"
              }
            },
            {
              "id": 654111,
              "key": "92a4a340-396d-419c-a513-4b0ab6a809d0",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Workspace How-to\n\nThe following video demonstrates how to work within the ***Project Workspace*** to complete the project. \n\nSpecifically it will cover the following topics:\n\n- How to get to the ***Project Workspace*** from a Lesson \n\n\n- What files you will be *editing* in the ***Project Workspace***\n\n\n- How to *edit*, *save*, and *run* python programs within the ***Project Workspace***\n\n\n- How to **reset** the ***Project Workspace*** back to its original state\n - When you **Reset** the Workspace, it will return to its original format:\n   - Any files you have *added* to the workspace are *deleted*\n   - All *edits* you have made to files that originally existed are *deleted*\n   \n- How to *download*, *upload*, and *delete* files from the workspace\n\n\n- How to return to a Lesson from the ***Project Workspace***\n\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 664285,
          "key": "d5764db0-3f62-497d-87d3-fded115b855d",
          "title": "Timing Code",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "d5764db0-3f62-497d-87d3-fded115b855d",
            "completed_at": "2020-03-26T20:15:20.270Z",
            "last_viewed_at": "2020-04-15T05:16:51.620Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 676210,
              "key": "921f5649-e4ad-4895-b47e-2c50140fd9f8",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# OK, lets start the project!",
              "instructor_notes": ""
            },
            {
              "id": 664287,
              "key": "add754cf-b6ab-47de-9485-935cdec28a45",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# ```#TODO: 0```:  Timing Code\n**Implement the start_time to measure total program runtime.**\n\n## Coding within the ***check_images.py***\n### Code to Edit within **Project Workspace - Timing **\n- The comments in the program header indicated by ```#TODO: 0```\n - Add your name\n - The date you started working on the project \n \n- Check the timing code within the ```main()``` function indicated by ```#TODO: 0```\n - We have added all the code you need to time your program. Here we expect that you will test our timing code by adding different values of seconds in the ```sleep()``` function to check how the timing and formatting of time works within the code we have provided.\n\n### Expected Outcome\nWhen completed this code will calculate the runtime of the program.  Specifically, this code will measure how long each of the three algorithms will take to classify all the images in the pet_images folder.   \n\n### Checking your code\nUse the ```sleep()``` function to test that your timing code is working correctly.\n\nTest the following:\n- Set different values of seconds in the ```sleep()``` function to check the timing and formatting of time.\n\n#### Project Workspace - Timing\n- The next concept will have your workspace to work on  ```#TODO: 0```\n- Editing of ***check_images.py*** can be done within the **Project Workspace - Timing**",
              "instructor_notes": ""
            },
            {
              "id": 664291,
              "key": "bfd9b8da-f47c-4fb1-b19b-706a41642e03",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## For additional information and help on ```#TODO: 0```, please look at the information below:\n\n",
              "instructor_notes": ""
            },
            {
              "id": 664290,
              "key": "02686caf-5f16-48d7-9947-9b6fb6d73a03",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "***\n## Importing Time Module\nTiming your program or a portion of your program's code, allows one to compare the _time_ costs associated with using different algorithms to solve a problem.  Additionally, timing your code allows one to know the _time_ costs associated with running a program using given computing resources.  \n\nTo time your code In python requires the import of the [```time()``` function](https://docs.python.org/3/library/time.html#time.time) from the [python time module](https://docs.python.org/3/library/time.html#module-time).  To simulate our program running for a certain period of time, we are going to use the time module's [```sleep()``` function](https://docs.python.org/2/library/time.html#time.sleep). It will pause the program execution for a set number of seconds. \n\nSince we only need to use the ```time()``` and ```sleep()``` functions, we will only import these two functions and not the entire time module. Only importing the functions from the module that you need saves on memory (RAM) your program requires to execute.\n\nSuch an import would look like the following:\n\n```python\n# Imports time() and sleep() functions from time module\nfrom time import time, sleep\n```",
              "instructor_notes": ""
            },
            {
              "id": 664292,
              "key": "ce6216bd-86fc-4a46-baa2-76ad90417638",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## Using Time and Sleep Functions\n\nTo time your code you will need to:\n\n- First, create a variable that records the ***start time*** (*start_time*), the point you want to *start* timing your code \n\n  \n- Next, create a variable that records the ***stop time*** (*end_time*), the point you want to *stop* timing your code \n\n\n- Finally, to calculate the ***total runtime*** (*tot_time*) by subtracting the *start_time* from *end_time* \n \n \n- **Note:** the following: \n - *tot_time* will be the total time your code ran in ***seconds***\n -  ```sleep()``` is used in the code below to *pause* the program execution for 75 seconds. To time actual code, you'd replace ```sleep(75)``` with the code that you wanted to time.\n\nThe code below demonstrates the use of ```time()``` and ```sleep()```.\n\n```python\n# Sets start time\nstart_time = time()\n\n# Replace sleep(75) below with code you want to time\nsleep(75)\n    \n# Sets end time\nend_time = time()\n\n# Computes overall runtime in seconds\ntot_time = end_time - start_time\n\n# Prints overall runtime in seconds\nprint(\"\\nTotal Elapsed Runtime:\", tot_time, \"in seconds.\")\n```",
              "instructor_notes": ""
            },
            {
              "id": 664294,
              "key": "f8dad186-3bb6-4c78-997a-4da87df81f08",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "***\n## Formatting Time \nLikely you will want to format your runtime into a nice format like *hh*:*mm*:*ss* where:\n - *hh* is two digit hours indicator\n - *mm* is two digit minutes indicator\n - *ss* is two digit seconds indicator  \n\nRecall the following regarding formatting time in seconds within python:\n\n- **3600** seconds in an hour\n- **60** seconds in a minute\n- [**/**](https://docs.python.org/3/library/operator.html#operator.truediv) (division operator) with [**int()** function](https://docs.python.org/3/library/functions.html#int) will return only the whole number part of a division\n- [**%**](https://docs.python.org/3/library/operator.html#operator.mod) (modulo operator) returns the remainder of a division\n- [**str() function**](https://docs.python.org/3/library/functions.html#func-str) converts numeric values into strings       \n- Lesson **Data Types and Operators**: *Arithmetic Operators* and *Integers and Floats* will help with formatting time in python.\n&nbsp; \n\nUsing the information above provides the following format of ***total runtime***, as *tot_time*:\n- hours = int( (tot_time / 3600) )\n- minutes = int(  ( (tot_time % 3600) / 60 )  )\n- seconds = int(  ( (tot_time % 3600) % 60 )  )      \n&nbsp; \n\nBelow you will find code that will print the runtime in the format *hh*:*mm*:*ss*:\n```python\n# Prints overall runtime in format hh:mm:ss\nprint(\"\\nTotal Elapsed Runtime:\", str( int( (tot_time / 3600) ) ) + \":\" +\n          str( int(  ( (tot_time % 3600) / 60 )  ) ) + \":\" + \n          str( int(  ( (tot_time % 3600) % 60 ) ) ) ) \n```\n### Note\nInstead of rounding to the nearest second, our code using the *__int()__* function and will truncate the value of seconds. This means if your *Total Runtime:* **4.519087974567**, then it would be formatted to *Total Runtime:* **0:0:4**.  If you instead want to *__round__* to the nearest second, you will want to replace the [*__int()__* function](https://docs.python.org/3/library/functions.html#int) with the [*__round()__* function](https://docs.python.org/3/library/functions.html#round) in calculating the number of *__seconds__* above.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 664296,
          "key": "9d7e918e-d5dc-4811-aa31-c3e392346da4",
          "title": "Project Workspace - Timing",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "9d7e918e-d5dc-4811-aa31-c3e392346da4",
            "completed_at": "2020-03-26T20:04:28.620Z",
            "last_viewed_at": "2020-04-15T05:18:09.754Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 664301,
              "key": "90cbf9bd-5935-4914-a129-f213d40cfb45",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "view77231794",
              "pool_id": "webterminal",
              "view_id": "77231794-ae8c-4454-be7d-d6018e1666db",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "userCode": "",
                    "openFiles": [
                      "/home/workspace/check_images.py"
                    ],
                    "showFiles": true,
                    "allowClose": true,
                    "showEditor": true,
                    "allowSubmit": false,
                    "terminalTitle": "BASH"
                  },
                  "kind": "generic"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 664304,
          "key": "421fba6c-826a-4333-a764-e1e6a97aa4df",
          "title": "Command Line Arguments",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "421fba6c-826a-4333-a764-e1e6a97aa4df",
            "completed_at": "2020-04-06T05:10:06.328Z",
            "last_viewed_at": "2020-04-16T19:09:28.779Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 664316,
              "key": "2e5cf22e-42bf-4c17-ae1f-d288dba3f725",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# ```#TODO: 1```:  Command Line Arguments\n**Fill code in the get_input_args() function to create & retrieve the command line arguments**\n\n### Code to Edit \nThis section will help you code the  function **get_input_args** within ***get_input_args.py***. With this function you will use argparse to retrieve three command line arguments from the user. (Argparse makes it easy to write user-friendly command-line interfaces).\n- Code for the function definition ```def get_input_args():``` as indicated by ```#TODO: 1```within ***get_input_args.py***.\n\n### Expected Outcome\n\nWhen completed this code will input the three command line arguments from the user. \n\n### Checking your code\nThe **check_command_line_arguments** function within ***check_images.py*** will check your code.\n\nTest the following:\n- Entering ***no*** command line arguments when you run ***check_image.py*** from the terminal window. This should result in the *default* values being printed.\n- Entering in values of your choosing for the command line arguments when you run ***check_image.py*** from the terminal window. This should result in the values you entered being printed.\n\n#### Project Workspace - Command Line Arguments\n- The next concept will have your workspace to work on  ```#TODO: 1```\n- Editing of ***check_image.py*** and ***get_input_args.py*** can be done within the **Project Workspace - Command Line Arguments**",
              "instructor_notes": ""
            },
            {
              "id": 664327,
              "key": "9ea22834-3ac2-40df-93f3-5a83a91d9ae7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## For additional information and help on ```#TODO: 1```, please look at the information below:\n\n",
              "instructor_notes": ""
            },
            {
              "id": 664317,
              "key": "d9242ed4-196b-40ce-ae51-822c1199a6a2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## Purpose\nThe purpose of command line arguments is to provide a way for your programs to be more flexible by allowing external inputs (command line arguments) to be input into a program. The key is that these external arguments can change as to allow more flexibility in the program.\n\nFor example, imagine you wrote a program that simply counts the number of lines in a file and prints out that number to the screen. To allow the user to enter in _any_ file without having to change the program, one would want to pass in the file location as a command line argument.  In this way, the program could be used on _any_ file since the value is passed as an external input at runtime. \n\n",
              "instructor_notes": ""
            },
            {
              "id": 664318,
              "key": "134f393d-4c67-4334-a127-aaef44ad7c61",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## Usage of Argparse:\n\nWe will be using the **argparse** module to input the following external inputs into our program **check_image.py**.  We recommend writing the **get_input_args** function to get the command line arguments using **argparse**.  \n\nBelow are the three external inputs your **check_image.py** program will need to retrieve from the user along with the suggested _default_ values each should have. \n\n- Folder that contains the pet images \n  - *pet_images/*\n\n\n- The CNN model architecture to use\n  - *resnet*, *alexnet*, or *vgg*  (pick one as the default). You will find them in **classifier.py**.\n\n\n- The file that contains the list of valid dognames \n - *dognames.txt*\n\n&nbsp;\n\n\nThe **get_input_args** function will need to create an argument parser object using [argparse.ArgumentParser](https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser) and then use the [add_argument method](https://docs.python.org/3/library/argparse.html#adding-arguments) to allow the users to enter in these three external inputs from above. \n\nBelow is an example of creating an argument parser object and then using **add_argument** to add an argument that's a path to a folder and a second argument that's an integer.\n```python\n# Creates Argument Parser object named parser\nparser = argparse.ArgumentParser()\n\n# Argument 1: that's a path to a folder\nparser.add_argument('--dir', type = str, default = 'pet_images/', \n                    help = 'path to the folder of pet images') \n\n```\nBelow you will find an explanation of the inputs into **add_argument**.\n- **Argument 1**:\n - --dir = The variable name of the argument  (here it's _dir_)\n\n - type = The type of the argument (here it's a string)\n\n - default = The default value (here it's 'pet_images/')\n\n - help = The text that will appear if the user types the program name and then -h or --help. This allows the user to understand the what's expected an argument's value\n",
              "instructor_notes": ""
            },
            {
              "id": 664319,
              "key": "afa345ee-6568-48cb-b36b-f366ce2a6cc6",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## Accessing Argparse Arguments\n\nTo access the arguments passed into the program through your argparse object, you will need to use the [**parse_args method**](https://docs.python.org/3/library/argparse.html#the-parse-args-method). The code below demonstrates how to access the arguments through the argparse extending the example above. \n\nTo begin, you will need to assign a variable to **parse_args** and then use that variable to access the arguments of your argparse object.  If you are creating the argparse object within a function, you will need to _return_ **parse_args** instead of assigning a variable to it. Also note that the variable **in_args** points to a collection of the command line arguments. \n\nThis means to access the one we created in the code above, we have to reference the collection variable name **in_args** then specify the command line argument variable name `dir`. For this example, it would be **in_args.dir**, where *in_args* is the collection variable name and *dir* refers to the command line argument variable name. Notice that you need a dot (.) separating the two variable names. The code below shows the assignment of **in_args** to our parser and then accessing the value of **in_args.dir** with the print statement.\n```python\n# Assigns variable in_args to parse_args()\nin_args = parser.parse_args()\n\n# Accesses values of Argument 1 by printing it\nprint(\"Argument 1:\", in_args.dir)\n```",
              "instructor_notes": ""
            },
            {
              "id": 664320,
              "key": "24fc6b93-10d3-46b9-8da8-ce4358a5be56",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## Running a Program using command line arguments\n\nTo run a program like **check_images.py**, first open a terminal window within the Project Workspace. Next type the following and hit enter to run the program (this example - check_images.py). Because no command line arguments are specified after the program name (this example - *check_images.py*) this will use the *default* command line arguments that have been defined.   \n```terminal\npython check_images.py \n```\nTo run a program like **check_images.py** using the command line argument `--dir`, first open a terminal window within the Project Workspace. Next type the following and hit enter to run the program (this example - check_images.py).  Notice that all command line arguments are specified after the program name (this example - *check_images.py*) and they are indicated by the **--** that proceeds their variable name (this example : *dir*) with the value following the variable name (in this example the string : *pet_images/*).   \n```terminal\npython check_images.py --dir pet_images/\n```\nIf you are having difficulty running **check_images.py** with command line arguments, see the example program call on *line 23* of the program.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 664306,
          "key": "dc760d34-1ce9-416d-a285-65a668980d2b",
          "title": "Project Workspace - Command Line Arguments",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "dc760d34-1ce9-416d-a285-65a668980d2b",
            "completed_at": "2020-04-06T05:15:32.438Z",
            "last_viewed_at": "2020-04-16T06:12:53.698Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 664307,
              "key": "9121cd15-6c44-484b-bd63-938a3e189886",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "view77231794",
              "pool_id": "webterminal",
              "view_id": "aea3235b-bdf4-40a2-ad6c-dcf5dd41f19b",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "userCode": "",
                    "openFiles": [
                      "/home/workspace/get_input_args.py"
                    ],
                    "showFiles": true,
                    "allowClose": true,
                    "allowSubmit": false
                  },
                  "kind": "generic"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 664410,
          "key": "6f6582ab-f29b-4b4e-b5ef-6a0e6fe15fe5",
          "title": "Mutable Data Types and Functions",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "6f6582ab-f29b-4b4e-b5ef-6a0e6fe15fe5",
            "completed_at": "2020-04-06T05:22:26.169Z",
            "last_viewed_at": "2020-04-15T05:22:43.461Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 664413,
              "key": "a4b1a4d7-2315-4cd0-9c09-c2c4598ad78e",
              "title": "AIPND Python Lab - Mutable Data Types and Functions Video",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "LIOmuZdLymw",
                "china_cdn_id": "LIOmuZdLymw.mp4"
              }
            },
            {
              "id": 664412,
              "key": "0f31bbd1-0c6a-434a-a257-8195c535bdb3",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "*At **3:35**  edit**_s_**_pets2( )  *should be*  ** edit_pets2( ) ** *, *At **4:46**  edit**_s_**_pets3( )    *should be*  **edit_pets3( )** *",
              "instructor_notes": ""
            },
            {
              "id": 664411,
              "key": "9f374d86-5d7c-407f-a65e-4a95e0d018d6",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Mutable Data Types and Functions\n*** \nIn the lesson **Data Types and Operators** you learned what it means if a data type is *mutable* or *immutable* when lists were introduced in *Lists and Membership Operators*.  Additionally, the lesson **Functions** demonstrated the scope of immutable python data types in *Variable Scope*.  \n\nThis concept will help you better understand how to use mutable data structures (like lists and dictionaries) within functions. This will be helpful in understanding how the data structures are used within **check_images** python program. \n\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 664415,
          "key": "1255a7f3-0fea-47df-aa2d-186594f3d7d5",
          "title": "Creating Pet Image Labels",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "1255a7f3-0fea-47df-aa2d-186594f3d7d5",
            "completed_at": "2020-04-06T06:01:18.619Z",
            "last_viewed_at": "2020-04-16T19:18:24.026Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 664419,
              "key": "66d2c74a-7baa-488e-8044-6fd2726e7b89",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# ```#TODO: 2```: Creating Pet Image Labels \n**Fill the get_pet_labels() function to create pet image labels by creating a dictionary with key=filename and value=file label.** (We will later use this to to check the accuracy of the classifier function)\n\n## Coding within the ***check_images.py*** and ***get_pet_labels.py***\n### Code to Edit \nThis section will help you code the function **get_pet_labels** within ***get_pet_labels.py***. With this function you will be creating the labels for the pet images, using the *filenames* of the pet images in the *pet_images* folder. These images filenames represent the identity of the pet in the image. The pet image labels are considered to represent the \"*truth*\" about the classification of the image. Your function will return the Results Dictionary that will contain the pet image filenames and labels.\n\n- Code for the function definition ```def get_pet_labels():``` as indicated by `#TODO: 2` within ***get_pet_labels.py***.\n - Follow the comments and the docstring within ***get_pet_labels.py*** to implement **get_pet_labels**  \n- Code within the ```main()``` function within ***check_images.py*** indicated by ```#TODO: 2```\n - Replace *None* within the function call with *in_arg.dir*  to specify the appropriate directory.\n\n### Expected Outcome\n\nWhen completed this code will return a dictionary with the *pet image filename* as the *key* and a *List* that contains only the *pet image label* as the *value* for all 40 pet images in the *pet_image* folder.\n\n### Checking your code\nThe **check_creating_pet_image_labels** function within ***check_images.py*** will check your code by printing out the number of key-value pairs and the first 10 key-value pairs.\n\nYou will need to visually check that the results show:\n- The dictionary containing 40 key-value pairs (e.g. dictionary length is 40).\n- The pet image labels the following way:\n  - Lower case letters\n -  Single space separating each word\n - Correct representation of the filenames (from the 10 key-value pairs)\n\n#### Project Workspace - Pet Image Labels\n- The next concept will have your workspace to work on `#TODO: 2`\n- Editing of ***check_image.py*** and ***get_pet_labels.py*** can be done within the **Project Workspace - Pet Image Labels**",
              "instructor_notes": ""
            },
            {
              "id": 664530,
              "key": "ff1989b7-dbb6-4584-8f20-c06df00eec5d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## For additional information and help on ```#TODO: 2```, please look at the information below:\n\n",
              "instructor_notes": ""
            },
            {
              "id": 664531,
              "key": "d2539282-10d3-4ab9-b866-a8aa2fcb9023",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## How to read *Filenames* from a Folder of Files\nThe folder **pet_images/** in the lab workspace contains the 40 images you will be testing the classifier algorithms on.  The filenames of the images in **pet_images/** identify the animal in each image.\n \nTo create the _labels_ for pet images you will need to:\n- Read all the files' names in the **pet_image/** folder\n- Process the filenames to create the pet image labels\n- Format the pet image labels such that they can be matched to:\n - The classifier function labels\n - The dog names in dognames.txt \n\nIn the first task the function will need to  read the filenames from a folder. To achieve this task you will need to only import the [listdir method](https://docs.python.org/3/library/os.html#os.listdir) from the [os python module](https://docs.python.org/3/library/os.html). The **listdir** method retrieves all filenames from the files within a folder. These filenames are returned from **listdir** as a list. The code below demonstrates how to perform this import and retrieval.\n```python\n# Imports only listdir function from OS module \nfrom os import listdir  \n\n# Retrieve the filenames from folder pet_images/\nfilename_list = listdir(\"pet_images/\")\n\n# Print 10 of the filenames from folder pet_images/\nprint(\"\\nPrints 10 filenames from folder pet_images/\")\nfor idx in range(0, 10, 1):\n    print(\"{:2d} file: {:>25}\".format(idx + 1, filename_list[idx]) )\n```",
              "instructor_notes": ""
            },
            {
              "id": 664532,
              "key": "6bcb76c1-0b16-4363-9a5d-5145b1e08fad",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## How to create a Dictionary of Lists (similar to the Results Dictionary)\nThe Python [Dictionary](https://docs.python.org/3/tutorial/datastructures.html#dictionaries) is the data structure you should use for the Pet Image filenames (as **keys**) and a *List* that contains the filenames associated labels (as **values**). The following are reasons for this data structure choice:\n- The key-value pairs of a dictionary are a logical choice because the need to process the same filenames (keys) with the **classifier function** and compare its returned labels to those of pet image (values)\n- Given an input key, retrieval of the associated value is quicker than retrieval from other data structures (e.g. lists).\n\n## Dictionary Usage Review\nIn the **Data Types and Operators** lesson you first learned about dictionaries . The code below will help you use Python dictionaries. \n- Creating an empty dictionary\n- Creating a dictionary that contains a *List* as the value.\n- Determines number of items in a dictionary \n- Adds key-value pairs to dictionary if key doesn't already exist in the dictionary\n- Iterates through a dictionary printing all key-value pairs in a dictionary  \n\n```python\n# Creates empty dictionary named results_dic\nresults_dic = dict()\n      \n# Determines number of items in dictionary\nitems_in_dic = len(results_dic)\nprint(\"\\nEmpty Dictionary results_dic - n items=\", items_in_dic)\n   \n# Adds new key-value pairs to dictionary ONLY when key doesn't already exist. This dictionary's value is\n# a List that contains only one item - the pet image label\nfilenames = [\"beagle_0239.jpg\", \"Boston_terrier_02259.jpg\"]\npet_labels = [\"beagle\", \"boston terrier\"]\nfor idx in range(0, len(filenames), 1):\n    if filenames[idx] not in results_dic:\n         results_dic[filenames[idx]] = [pet_labels[idx]]\n    else:\n         print(\"** Warning: Key=\", filenames[idx], \n               \"already exists in results_dic with value =\", \n               results_dic[filenames[idx]])\n\n#Iterating through a dictionary printing all keys & their associated values\nprint(\"\\nPrinting all key-value pairs in dictionary results_dic:\")\nfor key in results_dic:\n    print(\"Filename=\", key, \"   Pet Label=\", results_dic[key][0])\n```\n\n(For more details on the dictionary of lists see the **Classifying Images** section that's after the **Project Workspace - Pet Image Labels**).",
              "instructor_notes": ""
            },
            {
              "id": 664533,
              "key": "aaf5b688-7300-40eb-b8a1-d3f750c0444d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Pet Image File Format for Label Matching\nWith this project you will need to determine matches between the pet image labels and the classifier labels. To be able to accomplish this matching task with your function, you will need to understand the format of both labels. Below is a detailed description of the format the pet image filenames that you will be using to create the pet image labels.\n\n### Pet Image Files\nThe pet image files are located in the folder *'pet_images'*, in the workspace.  Some examples of the filenames you will see are: Basenji_00963.jpg, Boston_terrier_02259.jpg, gecko_80.jpg, fox_squirrel_01.jpg \n\nThere are:  \n- 40 total images pet images\n    - 30 images of dogs\n    - 10 images of animals that aren't dogs\n- Name (label) of image (**needed for comparison**)\n    - contains upper and lower case letters\n    - contains one or more words to describe the image (label)\n    - words are separated by an underscore (_)\n",
              "instructor_notes": ""
            },
            {
              "id": 664534,
              "key": "d02d8ae1-07c2-497b-a421-6669b52ed600",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Python functions to create Pet Image Labels\nThe best format for each pet image name would be:\n- Label: with only lower case letters\n- Blank space separating each word in a label composed of multiple words\n- Whitespace characters stripped from front & end of label\n\nIn the Lesson **Data Types and Operators** the sections on *Strings* and *String Methods*, you first learned about the string data type. Based upon the pet image filename format *above*, you can use the following string functions to achieve the label format:\n\n- [**lower()**](https://docs.python.org/3/library/stdtypes.html#str.lower) - places letters in lower case only.\n- [**split()**](https://docs.python.org/3/library/stdtypes.html#str.split) - returns a list of words from a string, where the words have been separated (split) by the delimiter provided to the split function. If no delimiter is provide, splits on whitespace. \n- [**strip()**](https://docs.python.org/3/library/stdtypes.html#str.strip) - returns a string with leading & trailing characters removed. If no characters are provided, strips leading & trailing whitespace characters.\n- [**isalpha()**](https://docs.python.org/3/library/stdtypes.html#str.isalpha) - returns true only when a string contains only alphabetic characters, returns false otherwise.\n\nBelow you will find some code that demonstrates use of the above string functions. ",
              "instructor_notes": ""
            },
            {
              "id": 664535,
              "key": "1e13d455-1e10-4f5a-afd5-eeffbca0d18d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "```python\n# Sets pet_image variable to a filename \npet_image = \"Boston_terrier_02259.jpg\"\n\n# Sets string to lower case letters\nlow_pet_image = pet_image.lower()\n\n# Splits lower case string by _ to break into words \nword_list_pet_image = low_pet_image.split(\"_\")\n\n# Create pet_name starting as empty string\npet_name = \"\"\n\n# Loops to check if word in pet name is only\n# alphabetic characters - if true append word\n# to pet_name separated by trailing space \nfor word in word_list_pet_image:\n    if word.isalpha():\n        pet_name += word + \" \"\n\n# Strip off starting/trailing whitespace characters \npet_name = pet_name.strip()\n\n# Prints resulting pet_name\nprint(\"\\nFilename=\", pet_image, \"   Label=\", pet_name)\n```",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 664416,
          "key": "c86ab728-6905-45d8-b5a7-025885d25e14",
          "title": "Project Workspace - Pet Image Labels",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "c86ab728-6905-45d8-b5a7-025885d25e14",
            "completed_at": "2020-04-06T06:18:43.603Z",
            "last_viewed_at": "2020-04-16T19:18:19.664Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 664417,
              "key": "5a6a8e71-8d66-4c14-8ae3-850c826aedd1",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "view77231794",
              "pool_id": "webterminal",
              "view_id": "08f2d613-1aa5-4594-a196-c65f0cbef3a0",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "userCode": "",
                    "openFiles": [
                      "/home/workspace/get_pet_labels.py"
                    ],
                    "showFiles": true,
                    "allowClose": true,
                    "allowSubmit": false
                  },
                  "kind": "generic"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 664536,
          "key": "14b77846-5f0f-4a1d-a726-522e5a969660",
          "title": "Classifying Images",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "14b77846-5f0f-4a1d-a726-522e5a969660",
            "completed_at": "2020-04-15T05:18:05.018Z",
            "last_viewed_at": "2020-04-16T19:18:11.308Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 664538,
              "key": "e0f1d8ba-08a8-4607-a30d-fe17b4c78bca",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# ```#TODO: 3```: Classifying Images \n**Implement the classify_images() function to create the classifier labels with the classifier function using in_arg.arch.  Compare the labels, and create a dictionary of results (result_dic).**\n\n## Code within the ***check_images.py*** and ***classify_images.py***\n### Code to Edit \nThis section will help you code the function **classify_images** within ***classify_images.py***. With this function you will be creating the labels for the images using the classifier function.  Additionally, you will be comparing these classifier's labels to the pet image labels.  Finally, you will be storing the classifier generated labels, and the comparison of labels in the results dictionary (complex data structure) that was returned by **get_pet_labels** function. \n\n- Code within the function  ```def classify_images()``` as indicated by ```#TODO: 3``` within ***classify_images.py*** \n - Using the comments and docstring within ***classify_images.py*** to define **classify_images** \n- Code within the ```main()``` function within ***check_images.py*** indicated by ```#TODO: 3```\n - Replace the first *None* within the function call to **classify_images** with *in_arg.dir* and replace the last *None* in the function call with *in_arg.arch*\n\n### Expected Outcome\n\nWhen completed this code will return a dictionary of lists with the *pet image filename* as the *key* and the *value* will be a list for all 40 pet images in the *pet_image* folder. This list will contain the following items: \n- Pet image label (index 0)\n- Classifier label (index 1)\n- Comparison of labels (index 2)\n\n### Checking your code\nThe **check_classifying_images** function within ***check_images.py*** will check your code. This function will print out all the *matches* between the classifier and pet image labels and then all the *non-matches* between the labels. \n\nVisually check that the results show:\n- Matches between Classifier and Pet Image Labels are *real* matches\n- Non-matches between Classifier and Pet Image Labels are *real* non-matches\n- The number of *matches* added to the number of *non-matches* totals **40**, to account for all 40 images in *pet_images* folder\n\n#### Project Workspace - Classifying Images\n- The next concept will have your workspace to work on `#TODO: 3`\n- Editing of ***check_image.py*** and ***classify_Images.py*** can be done within the **Project Workspace - Classifying Images**",
              "instructor_notes": ""
            },
            {
              "id": 665060,
              "key": "6ad7688a-3490-4faf-9100-a0840c4704ac",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## For additional information and help on ```#TODO: 3```, please look at the information below:\n\n",
              "instructor_notes": ""
            },
            {
              "id": 665061,
              "key": "04decae6-6e94-46ee-b99b-447474b23416",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## How to use the Classifier function\n### *Testing* the classifier function\nTest the environment and the **classifier function** that we will be using to classify the pet images. This function is located in the *classifier.py* program.  Test your environment by running the *test_classifier.py* program following the instructions below.  You can look at the *test_classifier.py* program to see how to use the **classifier function** within ***classify_images.py***.   \n\n1. Go to the **Lab Workspace - Classifying Images** concept.\n2. Open a terminal.\n3. Type the following on the command-line to test the classifier.py program. The image of the [**collie**](https://images.search.yahoo.com/yhs/search;_ylt=Awr9LvEdlU5bJ7QAXN8PxQt.?p=collie&fr=yhs-pty-pty_converter&fr2=piv-web&hspart=pty&hsimp=yhs-pty_converter&type=co_appfocus1_cr) should be correctly classified as a **collie**.    \n```\npython test_classifier.py \n```\n\n### Details on *test_classifier.py*\nLook at the **test_classifier.py** program you will notice the following:\n- The classifier function has to be imported into your program (*this is already done in **classify_images.py***).\n\n \n- The classifier function takes in two arguments:\n - The *full image path* (includes folder and filename).\n   - Folder and filename stored as separate variables, can be [concatenated](http://www.thefreedictionary.com/concatenated) together into a single string.\n - The CNN *model* architecture.\n   - Must be *resnet*,  *vgg* or *alexnet*\n\nTo view the code of ```test_classifier.py``` open the program in the Project Workspace - Classifying Images.",
              "instructor_notes": ""
            },
            {
              "id": 665062,
              "key": "fb4be2d0-1fc5-474b-85ec-1aca3bdd44aa",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Classifier Label Format for Label Matching\nYour function will need to be able to determine matches between the pet image labels and the labels the classifier function returns. To be able to accomplish this matching task with your function, you will need to understand the format of the classifier labels. Below is a detailed description of the format of the classifier labels.\n\n### Classifier Labels\nLabels are located in file *imagenet1000_clsid_to_human.txt* that you will see in the project workspace. \n\nLabel Information: \n- 1000 total labels\n    - associated to 118 different dog breeds\n         - dog breeds are associated to Ids 151: Chihuahua to 268: Mexican hairless\n    - associated to 882 images that aren't dogs\n- label format:\n    - a mixture of upper and lower case letters\n    - a single word that identifies the image\n         - Ex. *beagle*\n    - multiple words separated by spaces that identify the image\n         - Ex. *German shorthaired pointer*\n    - a number of different terms separated by a comma (,) that all identify the same image \n         - Ex. *cocker spaniel, English cocker spaniel, cocker*\n",
              "instructor_notes": ""
            },
            {
              "id": 665063,
              "key": "5fb1fca0-390f-4843-b6ec-19ec02eeee20",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "***\n## Comparing Pet Image Labels to Classifier Labels\nIn the **Creating Pet Image Labels** concept we formatted the pet image labels to be:\n\n- Label composed of all lower case letters\n- Blank space separating each word in label composed of multiple words\n- Whitespace characters stripped from front & end of label\n- Examples:\n - beagle \n - cocker spaniel\n - polar bear\n\nLooking at the classifier label format above, the only processing you will need to do is to put all the letters in lower case and to strip off any leading/trailing whitespace characters. The [**in** operation](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations) can be used to determine if the pet image label matches one of the terms that compose the classifier label.  The pet image labels are always only one term (even if multiple words make up that term). Therefore, if you discover (using the  [**in** operation](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations)) that your pet image label matches one term in the term (or terms) that make up a classifier label - then there's a match.  \n\nIn the Lesson **Data Types and Operators**  (of the Python lesson) you first learned about the string data type. To accomplish these formatting and matching tasks use the following string functions:\n\n- [**lower()**](https://docs.python.org/3/library/stdtypes.html#str.lower) - places letters in lower case only.\n- [**strip()**](https://docs.python.org/3/library/stdtypes.html#str.strip) - returns string with leading & trailing characters removed. If no characters are provided strips leading & trailing whitespace characters.\n- [**in** operation](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations)  - returns *True* when a string exists within another string, otherwise returns *False*.",
              "instructor_notes": ""
            },
            {
              "id": 665065,
              "key": "86dafaac-6d97-40b6-b044-354877c4e8da",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Data Structure for Results\n### Compound Data Structures\nIn the lesson **Data Types and Operators** you first learned about dictionaries. The **get_pet_labels** function returns a dictionary with the filenames as the *keys* and a list that contains only the pet image labels as the *values*. For the **classify_images** function, you can use the [**extend**](https://docs.python.org/3.1/tutorial/datastructures.html) list function to add both the classifier label and the comparison to the results dictionary simultaneously.\n\nIn the lesson **Data Types and Operators**, you first learned about compound data structures. You created and used a nested dictionary to hold information about the elements.  For the compound data structure we recommend using a dictionary of lists(*values*).  If you choose to use a different compound data structure the the following check functions will not work:\n - **check_creating_pet_image_labels**\n - **check_classifying_images**\n - **check_classifying_labels_as_dogs**\n - **check_calculating_results**\n\nThe reason behind this choice of data structures is:\n- It's easier to access elements of the list using index values \n- You can use the [sum()](https://docs.python.org/3/library/functions.html#sum) function with [slicing](https://docs.python.org/3/tutorial/introduction.html#lists) to quickly classify the results\n\n### Computing the Results\nFor this function you will be inputing the *results_dic* dictionary that contains:\n-  The *filenames* as *keys* \n- A *list* whose only item is the *pet image label*.\n\nYou will need to:\n\n1) Iterate through this dictionary (*results_dic*) processing each pet image (filename) with the **classifier function** to get the classifier label. \n\n2) Compare the pet image and classifier labels to determine if they match.\n\n3) Add the results to the results dictionary (*results_dic*).\n\n (In **Mutable Data Types and Functions** you learned that because the results dictionary is a mutable data type you don't need to return it from the **classify_images** function).\n\nCoding recommendations as to prevent issues with **classify_images**:\n- With the **classifier function**, be certain to concatenate the *images_dir* with the *filename* to represent the *full* path to each pet image file. \n- Put classifier labels in *all* lower case letters, stripping leading and trailing whitespace from the label.\n- ***results_dic*** will have the following format:\n - *key* = pet image filename (ex: Beagle_01141.jpg)\n - *value* = List with:\n   - index 0 = Pet Image Label (ex: beagle)\n   - index 1 = Classifier Label (ex: english foxhound)\n   - index 2 = 0/1 where 1 = labels match , 0 = labels don't match (ex: 0)\n - example_dictionary = {'Beagle_01141.jpg': ['beagle', 'english foxhound', 0]}\n- To *initialize* a key in *results_dic*, use the *assignment* operator ( = ) to assigning the value of a list.\n- To add a single item to the list of an **existing** *key* in *results_dic*, append to the list using either *+=* operator or the *append* function.\n- To add multiple items simultaneously to the list of an **existing** *key* in *results_dic*, use the [**extend**](https://docs.python.org/3.1/tutorial/datastructures.html) list function.\n \nFor more details on using a dictionary of lists see the example code below. This demonstrates the difference between *initializing* a key-value pair and adding to the list of an *existing* key-value pair.  The code also demonstrates how to iterate through a dictionary of lists to access each element of the list.",
              "instructor_notes": ""
            },
            {
              "id": 665066,
              "key": "78663ca2-ab56-4a3b-bfad-ce88f12bb24f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "```python\n# Defining lists to populate dictionary \nfilenames = [\"Beagle_01141.jpg\", \"Beagle_01125.jpg\", \"skunk_029.jpg\" ]\npet_labels = [\"beagle\", \"beagle\", \"skunk\"]\nclassifier_labels = [\"walker hound, walker foxhound\", \"beagle\",\n                     \"skunk, polecat, wood pussy\"]\npet_label_is_dog = [1, 1, 0]\nclassifier_label_is_dog = [1, 1, 0]\n\n# Defining empty dictionary\nresults_dic = dict()\n    \n# Populates empty dictionary with both labels &indicates if they match (idx 2)\nfor idx in range (0, len(filenames), 1):\n    # If first time key is assigned initialize the list with pet & \n    # classifier labels\n    if filenames[idx] not in results_dic:\n        results_dic[filenames[idx]] = [ pet_labels[idx], classifier_labels[idx] ]\n \n    # Determine if pet_labels matches classifier_labels using in operator\n    # - so if pet label is 'in' classifier label it's a match\n    # ALSO since Key already exists because labels were added, append \n    # value to end of list for idx 2 \n    # if pet image label was FOUND then there is a match \n    if pet_labels[idx] in classifier_labels[idx]:\n        results_dic[filenames[idx]].append(1)\n            \n    # if pet image label was NOT found then there is no match\n    else:\n        results_dic[filenames[idx]].append(0)\n\n# Populates dictionary with whether or not labels indicate a dog image (idx 3&4)\nfor idx in range (0, len(filenames), 1):\n    # Key already exists, extend values to end of list for idx 3 & 4\n    results_dic[filenames[idx]].extend([pet_label_is_dog[idx], \n                                       classifier_label_is_dog[idx]])\n        \n# Iterates through the list to print the results for each filename\nfor key in results_dic:\n    print(\"\\nFilename=\", key, \"\\npet_image Label=\", results_dic[key][0],\n          \"\\nClassifier Label=\", results_dic[key][1], \"\\nmatch=\",\n          results_dic[key][2], \"\\nImage is dog=\", results_dic[key][3],\n          \"\\nClassifier is dog=\", results_dic[key][4])                        \n\n    # Provides classifications of the results\n    if sum(results_dic[key][2:]) == 3:\n        print(\"*Breed Match*\")\n    if sum(results_dic[key][3:]) == 2:\n        print(\"*Is-a-Dog Match*\")\n    if sum(results_dic[key][3:]) == 0 and results_dic[key][2] == 1:\n        print(\"*NOT-a-Dog Match*\")\n```",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 664537,
          "key": "55034101-635d-48a0-9a69-1e14e83d44a0",
          "title": "Project Workspace - Classifying Images",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "55034101-635d-48a0-9a69-1e14e83d44a0",
            "completed_at": "2020-04-15T06:32:43.170Z",
            "last_viewed_at": "2020-04-15T21:23:11.114Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 665069,
              "key": "804e0bca-25ad-42c4-ba6c-ea385a9193ae",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "view77231794",
              "pool_id": "webterminal",
              "view_id": "e9e7c2b5-2581-45b1-8a3c-4092a4882be0",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "userCode": "",
                    "openFiles": [
                      "/home/workspace/classify_images.py"
                    ],
                    "showFiles": true,
                    "allowClose": true,
                    "allowSubmit": false
                  },
                  "kind": "generic"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 665067,
          "key": "ff6e88c7-5dfb-4e9e-8031-df84b9ef64a8",
          "title": "Classifying Labels as Dogs",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "ff6e88c7-5dfb-4e9e-8031-df84b9ef64a8",
            "completed_at": "2020-04-15T20:10:38.032Z",
            "last_viewed_at": "2020-04-16T19:22:24.733Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 665071,
              "key": "b28c6cde-1d7b-456f-91a0-7a2abfd4db3b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# ```#TODO: 4```: Classifying Labels as Dogs\n**Implement the adjust_results4_isadog() function to adjust the results of dictionary(result_dic) to determine if the classifier correctly classified images as 'a dog' or 'not a dog'.**\n\n\n## Coding within the ***check_images.py*** and ***adjust_results4_isadog.py***\n### Code to Edit \nThis section will help you code the *undefined* function **adjust_results4_isadog** within ***adjust_results4_isadog.py***. \n\nWith this function you will:\n- Read in the dog names from *dognames.txt* file into a data structure (like a dictionary)\n- Compare the dog names to the classifier and pet image labels in the results dictionary\n- Adjust the results dictionary to indicate whether or not these labels indicate the image is 'of-a-dog'. \n\n Note that the **adjust_results4_isadog** function will change the results dictionary, but because dictionaries are mutable you won't have to return this dictionary (review the section *Mutable Data Types and Functions* if you want a more detailed explanation).\n\n\n- Code for the function definition ```def adjust_results4_isadog():``` as indicated by ```#TODO: 4``` within ***adjust_results4_isadog.py***.\n - Using the comments and docstring within ***adjust_results4_isadog.py*** to define **adjust_results4_isadog** \n- Code within the ```main()``` function within ***check_images.py***  indicated by ```#TODO: 4```\n - Replace *None* within the function call to **adjust_results4_isadog** with *in_arg.dogfile*.\n\n### Expected Outcome\n\nWhen completed this code will have altered the results dictionary (a dictionary of lists) with the *pet image filename* as the *key* and the *value* will be a list for all 40 pet images in the *pet_image* folder. This list for each *key* will now contain two additional items:  whether the pet image label is of-a-dog (index 3) and whether the classifier label is of-a-dog (index 4).\n\n### Checking your code\nThe **check_classifying_labels_as_dogs** function within ***check_images.py***  will check your code. This function will print out all the *matches* between the classifier and the pet image labels and all the *non-matches* between the labels.\n\nVisually check that the results show:\n- Matches between Classifier and Pet Image Labels have both labels classified as \"dogs\" or \"not dogs\" as appropriate for the labels.\n- Non-matches between Classifier and Pet Image Labels correctly classify each label as \"dogs\" or \"not dogs\" \n- The number of *matches* added to the number of *non-matches* totals **40**, to account for all 40 images in *pet_images* folder.\n\n#### Project Workspace - Adjusting Results\n- The next concept will have your workspace to work on `#TODO: 4`\n- Editing of ***check_image.py*** and ***adjust_results4_isadog.py*** can be done within the **Project Workspace - Adjusting Results**",
              "instructor_notes": ""
            },
            {
              "id": 665072,
              "key": "d396c944-acdc-4955-aba9-dce8785b7a07",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## For additional information and help on ```#TODO: 4```, please look at the information below:\n\n",
              "instructor_notes": ""
            },
            {
              "id": 665073,
              "key": "9792936e-ff4b-442c-b549-2ff41ab21991",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## **Define:** \"Is a Dog\" / \"Is NOT a Dog\" by Reviewing Dog Names File\n\n### Lets remember the  principle objectives _1_ and _2_:\n1. Correctly identify which pet images are of dogs (even if breed is misclassified) and which pet images aren't of dogs.  \n\n2. Correctly classify the breed of dog for the images that are of dogs.   \n&nbsp; \n\nTo achieve objectives _1_ and _2_, your program will have to be able to identify if labels from both the classifier function and the pet images are of \"_a dog_\" or \"_not a dog_\".  To be able to classify the labels as \"_dogs_\" or \"_not dogs_\", your program will need to compare the labels to the list of dogs contained in the **dognames.txt** file in the workspace.  \n\nThis **dognames.txt** file was created from the formatted labels (lower case, whitespace trimmed, etc.). Therefore, when comparing *dog names* (from dognames.txt) to your *labels*:\n- if there is a match between *dog name* and *label*, the label \"**is a dog**\"  \n-  if there isn't a match between *dog name* and *label*, the label \"**is *not* a dog**\" \n\n### Details about _dognames.txt_:\n\nThere are: \n- One dog breed name per line\n- 223 dog breeds named \n- All possible dog breeds that can come from the classifier function and pet image labels\n- _Classifier Function Labels:_ \n - Lines **1** (chihuahua) to **118** (mexican hairless), these should match classifier returned labels as long as those labels are in _all_ lower case letters and have whitespace characters trimmed from the ends.\n- _Pet Image Labels:_ \n - Should match the following lines as long as the labels are in _all_ lower case letters, whitespace has been trimmed from the ends, and there is a single space separating the words of a dogs name (if it's composed of multiple words).\n",
              "instructor_notes": ""
            },
            {
              "id": 665074,
              "key": "fb5864a5-6bf7-440e-9732-754493cb1b87",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Reading In Dogsname.txt\n\nThe first task of the **adjust_results4_isadog** will be to read in all the _dog names_ and store them in a data structure.  Given the details above, the most ideal data structure for our _dog names_ is a dictionary with the key as the _dog name_ and a value of 1 (arbitrary value). The reasoning behind this choice is because the speed of the look-up of a dictionary.  Since we know the labels should match the _dog name_ exactly if there is a match; we can simply _look_ for the label as a key within the dog names dictionary to discover all labels that are _dogs_.  If the label isn't found as a key in the dog names dictionary, then we know that label is _not_ a dog.\n\nIn the lesson **Scripting** we demonstrated how to open and read information from a file. Please review this section if you are having difficulty reading the dog names from *dognames.txt*. \n\nCoding recommendation as to prevent issues with **adjust_results4_isadog**:\n- Define the *dognames_dic* prior to opening the *dognames.txt* file for reading\n- Use [**rstrip()**](https://docs.python.org/3/library/stdtypes.html#str.rstrip) to strip off newline characters from each line read from *dognames.txt*   \n- If a *dog name* already exists in *dognames_dic* print a **Warning** statement because you shouldn't find any duplicate *dog names* in *dognames.txt*",
              "instructor_notes": ""
            },
            {
              "id": 665075,
              "key": "edbc0367-f225-416c-8079-9f132b7f8015",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "***\n## Adjusting Results Dictionary \nOnce you have read in the *dog names* into *dognames_dic*, you will need to adjust the results dictionary (*results_dic*) to account for when labels were correctly or incorrectly classified as dogs.\n\nReview section *Classifying Labels as Dogs* to review how to iterate through the results dictionary to append values onto the *list* that is the *value* for each *key* in the results dictionary.  If you want to append both values at the same time, you will need to use the [**extend**](https://docs.python.org/3.1/tutorial/datastructures.html) list function to add both **index 3** and **index 4** to the *results_dic* simultaneously. \n\n**results_dic** will have the following ***adjusted*** format:\n - *key* = pet image filename (ex: Beagle_01141.jpg)\n - *value* = List with:\n   - index 0 = Pet Image Label (ex: beagle)\n   - index 1 = Classifier Label (ex: english foxhound)\n   - index 2 = 0/1 where 1 = labels match , 0 = labels don't match (ex: 0)\n   - ***index 3*** = 0/1 where 1= Pet Image Label is a dog, 0 = Pet Image Label isn't a dog (ex: 1)\n   - ***index 4*** = 0/1 where 1= Classifier Label is a dog, 0 = Classifier Label isn't a dog (ex: 1)\n - example_dictionary = {'Beagle_01141.jpg': ['beagle', 'walker hound, walker foxhound', 0, 1, 1]}\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 665068,
          "key": "aaae1a0c-2aa4-4531-942b-550e7b0e2786",
          "title": "Project Workspace - Adjusting Results",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "aaae1a0c-2aa4-4531-942b-550e7b0e2786",
            "completed_at": "2020-04-15T21:24:01.990Z",
            "last_viewed_at": "2020-04-16T19:52:13.808Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 665070,
              "key": "1652e5da-aa5d-4ed2-9aa2-60b9272777e1",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "view77231794",
              "pool_id": "webterminal",
              "view_id": "6cc35393-4b62-4882-ad41-c3215eb2236d",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "userCode": "",
                    "openFiles": [
                      "/home/workspace/adjust_results4_isadog.py",
                      "/home/workspace/adjust_results4_isadog_hints.py"
                    ],
                    "showFiles": true,
                    "allowClose": true,
                    "allowSubmit": false
                  },
                  "kind": "generic"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 665076,
          "key": "75b4ad8e-9d8a-4274-8baf-1aec7fbaaf9a",
          "title": "Calculating Results",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "75b4ad8e-9d8a-4274-8baf-1aec7fbaaf9a",
            "completed_at": "2020-04-15T22:35:06.244Z",
            "last_viewed_at": "2020-04-16T04:01:06.224Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 665086,
              "key": "f798dcc1-2bc5-440a-bb04-e0df04f10632",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# ```#TODO: 5```: Calculating Results\n**Implement the calculates_results_stats() function to calculate the results of run and put statistics in a results statistics dictionary (results_stats_dic).**\n\n## Coding within the ***check_images.py*** and ***calculates_results_stats.py***\n### Code to Edit \nThis section will help you code the *undefined* function **calculates_results_stats** within ***calculates_results_stats.py***. With this function you will be inputing the results dictionary to create a dictionary of results statistics. This results statistics dictionary will contain the *statistic's name* as the *key* and the *value* will simply be the *statistic's numeric* value.\n \nYou will be creating the results statistics dictionary within **calculates_results_stats**. This means we recommend that you create this dictionary as the first line in your function and return it's value with the last line in your function.  For a more detailed explanation regarding why this dictionary is returned by the function, review the section *Mutable Data Types and Functions*.\n\n- Code for the function definition ```def calculates_results_stats():``` as indicated by ```#TODO: 5``` within ***calculates_results_stats.py***\n - Using the comments and the docstring within ***calculates_results_stats.py*** to define **calculates_results_stats**\n\n### Expected Outcome\n\nWhen completed, this code will be able to provide counts and percentages that will be used to answer the objectives of this lab. The percentages provided by the *results_stats* dictionary will answer objectives 1 and 2. The counts will be used to compute the percentages.\n\n### Checking your code\n The **check_calculating_results** function within ***check_images.py*** will check your code by recalculating the following results statistics (counts and percentages) and comparing them to the results statistics that you calculated and stored within the results statistics dictionary.\n\nResults Statistics checked:\n- **Counts**:\n - Number of  Images\n - Number of Dog Images\n - Number of \"Not-a\" Dog Images\n- **Percentages**:\n - % Correctly Classified Dog Images\n - % Correctly Classified \"Not-a\" Dog Images\n - % Correctly Classified Breeds of Dog Images\n\nVisually check that the results from this *checking* code for these six statistics above *match* the results you computed with **calculates_results_stats**  within ***calculates_results_stats.py***. \n\n#### Project Workspace - Calculating Results\n- The next concept will have your workspace to work on `#TODO: 5`\n- Editing of ***check_image.py*** and ***calculates_results_stats.py*** can be done within the **Project Workspace - Calculating Results**",
              "instructor_notes": ""
            },
            {
              "id": 665098,
              "key": "ad747c9c-f5b5-4a44-8c67-2e4ffd98d8c0",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## For additional information and help on ```#TODO: 5```, please look at the information below:\n",
              "instructor_notes": ""
            },
            {
              "id": 665087,
              "key": "282089d4-ba0a-44d0-ad58-d3b7eec62ba3",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## How to Define Percentages for Summarizing the Results\n\n###  Principle Objectives _1_ and _2_:\n1. Correctly identify which pet images are of dogs (even if breed is misclassified) and which pet images aren't of dogs.  \n2. Correctly classify the breed of dog, for the images that are of dogs.   \n&nbsp; \n\nTo achieve objectives _1_ and _2_, your program will need to be able to calculate the following percentages based upon the results of comparing the labels contained within the results dictionary. \n\nThe **results dictionary** will have the following format:\n - *key* = pet image filename (ex: Beagle_01141.jpg)\n - *value* = List with:\n   - index 0 = Pet Image Label (ex: beagle)\n   - index 1 = Classifier Label (ex: english foxhound)\n   - index 2 = 0/1 where 1 = labels match , 0 = labels don't match (ex: 0)\n   - index 3 = 0/1 where 1= Pet Image Label is a dog, 0 = Pet Image Label isn't a dog (ex: 1)\n   - index 4 = 0/1 where 1= Classifier Label is a dog, 0 = Classifier Label isn't a dog (ex: 1)\n - example_dictionary = {'Beagle_01141.jpg': ['beagle', 'walker hound, walker foxhound', 0, 1, 1]}\n\nYou will be storing these calculations (counts & percentages) in the results statistics dictionary. We recommend using the same prefix for all counts (e.g. *n_*) and percentages (e.g. *pct_*) in the statistic's name(*key*) as to make it easier to print all of them for each group.\n\nThe **results statistics dictionary** will have the following format:\n- *key* = statistic's name (e.g. n_correct_dogs, pct_correct_dogs, n_correct_breed, pct_correct_breed)\n- *value* = statistic's value (e.g. 30, 100%, 24, 80%)\n- example_dictionary = {'n_correct_dogs': 30, 'pct_correct_dogs': 100.0, 'n_correct_breed': 24, 'pct_correct_breed': 80.0}",
              "instructor_notes": ""
            },
            {
              "id": 665088,
              "key": "56fc6524-a442-4f83-9333-aac328de2dbf",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## Counts Computed from the *Results* dictionary for input into the *Results Statistics* dictionary:\n- **Z**: Number of Images\n - length of *results_dic*, because filenames = key\n- **A**: Number of Correct Dog matches \n - Both labels are of dogs: *results_dic*[key][3] = 1 and *results_dic*[key][4] = 1\n- **B**: Number of Dog Images\n -  Pet Label is a dog: *results_dic*[key][3] = 1\n- **C**: Number of Correct Non-Dog matches \n - Both labels are NOT of dogs: *results_dic*[key][3] = 0 and *results_dic*[key][4] = 0\n- **D**: Number of Not Dog Images \n -  number images - number dog images --OR-- \n - Pet Label is NOT a dog: *results_dic*[key][3] = 0\n- **E**: Number of Correct Breed matches \n - Pet Label is a dog & Labels match: *results_dic*[key][3] = 1 and *results_dic*[key][2] = 1\n- (*Optional*) **Y**: Number of label matches\n - Labels match: *results_dic*[key][2] = 1\n",
              "instructor_notes": ""
            },
            {
              "id": 665089,
              "key": "f55dd655-930c-48fd-a13e-4dd9f4199384",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## Compute  a Summary of the Percentages from the *Results Statistics* dictionary counts:\n - **Objective _1_a**: Percentage of Correctly Classified Dog Images\n   - **A** Correctly classified _dog_ images.\n   - **B** Number of _dog_ images   \n   - Percentage of correctly classified \"_dog_\" images: **A**/**B** * 100\n\n - **Objective _1_b**: Percentage of Correctly Classified Non-Dog Images\n   - **C** Correctly classified _NOT a dog_ images.\n   - **D** Number of _NOT a dog_ images   \n   - Percentage of correctly classified \"_Non-dog_\" images: **C**/**D** * 100\n\n - **Objective _2_**: Percentage of Correctly Classified Dog Breeds\n   - **E** Correctly classified as a particular breed of _dog_ images.\n   - **B** Number of _dog_ images   \n   - Percentage of correctly classified _Dog_ Breed images: **E**/**B** * 100\n\n - (*Optional*): Percentage Label Matches ( regardless if they're a dog)\n   - **Y** Number of label matches\n   - **Z** Number of images   \n   - Percentage of correctly Matched Images ( regardless if they are a dog): **Y**/**Z** * 100\n\n**Important Notes**:\n- You will need to initialize all the counts to a value of zero before iterating through *results* dictionary. As you iterate through *results* dictionary, if certain criterion are met you will need to increment these counters by 1.\n\n\n- The percentages (and total number of images) can be generated from the counts (see percentage & count calculations above); therefore, these values should be calculated *after* counts have been calculated by iterating through the *results* dictionary. \n\n\n- When calculating the percentage of correctly classified Non-Dog Images, use a conditional statement to check that **D**, the number of \"not-a-dog\" images, is greater than zero. To avoid division by zero error, only if **D** is greater than zero should **C**/**D**  be computed; otherwise, this should be set to 0. \n\n\n- Because the *Results Statistics* dictionary is created inside of the function and is a mutable object, you will need to *return* it's value at the end of the function (see section *Mutable Data Types and Functions*).\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 665077,
          "key": "41b54fb1-1264-40a2-a533-7973a287e221",
          "title": "Project Workspace - Calculating Results",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "41b54fb1-1264-40a2-a533-7973a287e221",
            "completed_at": "2020-04-15T22:35:19.714Z",
            "last_viewed_at": "2020-04-16T04:00:25.831Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 665085,
              "key": "4cdbee4d-ab8b-42e1-a714-43e3433cfdb6",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "view77231794",
              "pool_id": "webterminal",
              "view_id": "1c8e2b42-eb8e-42e4-b4c2-d2098f95b68d",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "userCode": "",
                    "openFiles": [
                      "/home/workspace/calculates_results_stats.py",
                      "/home/workspace/calculates_results_stats_hints.py"
                    ],
                    "showFiles": true,
                    "allowClose": true,
                    "allowSubmit": false
                  },
                  "kind": "generic"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 665078,
          "key": "48649f26-3e98-42a1-b888-e6e616b3fe10",
          "title": "Printing Results",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "48649f26-3e98-42a1-b888-e6e616b3fe10",
            "completed_at": "2020-04-16T04:38:47.815Z",
            "last_viewed_at": "2020-04-16T05:24:28.934Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 665090,
              "key": "2f160975-7784-4505-8efa-b3b03c01ea9f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# ```#TODO: 6``` Printing The Results\n**Implement the print_results() function to print a summary of the results (as well as incorrect classifications of dogs and breeds if requested).**\n\n## Coding within the ***check_images.py*** and ***print_results.py***\n### Code to Edit \nThis section will help you code the *undefined* function **print_results** within ***print_results.py***. With this function you will be inputting the *results* dictionary and the *results statistics* dictionary to print a summary of the results.  Because this function allows one to print a list of incorrectly classified dogs and incorrectly classified breeds of dog, one needs to include the *results* dictionary.  \n \n- Code for the function definition ```def print_results():``` indicated by ```#TODO: 6``` within ***print_results.py***\n - Using the comments and the docstring within ***print_results.py*** to define **print_results** \n- Code within the ```main()``` function within ***check_images.py*** indicated by ```#TODO: 6```\n - Replace the *None* within the function call to **print_results** with *in_arg.arch* \n\n### Expected Outcome\n\nWhen completed, this code will print the summary of the results that will be used to answer objectives 1 and 2 of this project. \n\n### Checking Your Code\n\nFor this you will just be running the completed program to visually check the following:\n- Running the program results in the statistics and counts being properly printed and formatted. Results from the *code check* for *Calculating Results* should match the values printed for those 6 statistics.\n- Leaving *off* the two default arguments in the function call to **print_results**, results in no misclassifications being printed (That's an expected default behavior).\n- Adding the values of *True* for the two default arguments in the function call to **print_results**, results in the misclassifications being printed (That's also an expected default behavior).\n\n### Final Program Run\nOnce you are satisfied the program is running properly use batch processing (see section on *Batch Processing* below) to run the program for all **three** CNN model architectures. You will use these results to compare them with our results in the section **Final Results**.\n\n\n#### Project Workspace - Printing Results\n- The next concept will have your workspace to work on `#TODO: 6`\n- Editing of ***check_image.py*** and ***print_results.py*** can be done within the **Project Workspace - Printing Results**.",
              "instructor_notes": ""
            },
            {
              "id": 665099,
              "key": "600bf414-552a-4511-b8f8-66f53e153a7d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## For additional information and help on ```#TODO: 6```, please look at the information below:\n",
              "instructor_notes": ""
            },
            {
              "id": 665091,
              "key": "f9cb5aef-7dae-47e0-94c7-68a48b2b5c29",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## Printing Results\n\nThe first thing to be printed is a general statement that indicates which of the three CNN model architectures you are using. You can pass the information in the *model* as an input parameter to be able to print it. \n\nNext you will be printing the overall count which will be the same for all three CNN model architectures. This can be done by calling for those counts using the appropriate key within a print statement.\n- Number of Images\n- Number of Dog Images\n- Number of \"Not-a\" Dog Images\n\nFinally, you will be iterating through the *results_stats* dictionary printing out the statistic's name and value for all of the percentages (e.g. key that starts with the letter \"*p*\").  Recall that we had recommended that you give the same prefix (e.g. *pct_*) to all of the percentage statistics, so that they could all be printed out as a group.\n\nPercentage Calculations:\n- % Correct Dogs\n- % Correct Breed\n- % Correct \"Not-a\" Dog\n- % Match (*optional* - this includes both dogs and not-a dog)",
              "instructor_notes": ""
            },
            {
              "id": 665092,
              "key": "633f71bf-025d-47e7-aa4a-2ecfe02325d5",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\n## Printing Misclassifications\nThis function allows one to *optionally* print cases of *dog* and *breed* misclassifications.\n\nThis optional feature is provided to allow improved debugging of the code.  Additionally, this feature provides the ability to determine if there are certain breeds of dogs that the algorithms have difficulty identifying.\n\n\n### Default Arguments for Misclassification\nThe function **print_results** contains two default arguments for printing misclassified *dogs* and *breeds*. (In the lesson **Functions**  you first learned about default arguments). \n\n**Default Arguments**:\n- *print_incorrect_dogs* - defaults to *False*\n- *print_incorrect_breed* - defaults to *False*\n\n#### Purpose\n\nThe purpose of default arguments can be the following:\n- To provide a wider range of behaviors for a function, without having to code multiple (similar) functions.\n- To guarantee that certain arguments are always assigned a value within a function. \n- To provide a default behavior for a function. \n\n\n### Misclassified Dogs\nLabels are misclassified as dogs when both labels aren't in agreement regarding whether or not an image is of a dog. \n\nPrior to iterating through the *results* dictionary to find dog misclassifications, you must first check that the user *wants* to print misclassified dogs and that dog misclassifications *occurred* with a conditional statement.\n\nThis check is done when:\n - User wants to print misclassifications:\n   - *print_incorrect_dogs* == True \n - Some dogs were misclassified:\n   - n_correct_dogs + n_correct_notdogs != n_images\n     \n\n  \nIf the check is *True*, then print the pet image and classifier labels for misclassified dogs when:\n -  The labels disagree on whether or not an image is of a \"dog\"\n   - sum(results_dic[key][3:]) == 1 \n\n\n### Misclassified Breed's of Dog\nLabels have a misclassification of breeds of dog when both labels indicate that the image is a dog; but, labels aren't in agreement regarding the dog's breed.\n\nPrior to iterating through the *results* dictionary to find breed misclassifications, you must first check that the user *wants* to print misclassified breeds and that breed misclassification *occurred* with a conditional statement.\n\nThis check is done when:\n - User wants to print misclassifications:\n   - *print_incorrect_breed* == True \n - Some breeds were misclassified:\n   - n_correct_dogs != n_correct_breed\n    \n\n  \nIf the check is *True*, then print the pet image and classifier labels for misclassified breeds when:\n -  When the labels agree that image is of a dog, but disagree on the breed of dog\n   - sum(results_dic[key][3:]) == 2 and results_dic[key][2] == 0 ",
              "instructor_notes": ""
            },
            {
              "id": 665093,
              "key": "adf0acef-0f36-4279-a7de-0e43f097253e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "***\n## Batch Processing\nNow that you have completed coding check_images.py, you are ready to run it on all 3 models. One way to do this is to call the program from the terminal window for one of the models, wait until it completes running, record it's results, and then repeat for the other two models.\n\nAn easier way to handle this task is with batch processing using a shell script. For this exercise, you will find the bash program **run_models_batch.sh** in the workspace. Open that file and you will notice comments use # just like python and the rest look the same as the commands you type into the terminal window to run your program (see code below).\n```bash\n#  Code from run_models_batch.sh \npython check_images.py --dir pet_images/ --arch resnet  --dogfile dognames.txt\n     > resnet_pet-images.txt\npython check_images.py --dir pet_images/ --arch alexnet  --dogfile dognames.txt  \n     > alexnet_pet-images.txt\npython check_images.py --dir pet_images/ --arch vgg  --dogfile dognames.txt \n     > vgg_pet-images.txt\n```\nYou will also notice that each file ends with *> filename.txt*. The *>* is a pipe and it pipes the output from the console into a file. The file contains the filename of the model being used.  This way after each run, the results are automatically stored in your workspace.\n\nTo run file **run_models_batch.sh** in the workspace, open a terminal window (in Unix/Linux/OSX/Lab Workspace) and type the following:   \n```terminal\nsh run_models_batch.sh\n```\nIf you want to *batch process* the program on a Windows computer you will need to follow the instructions found [here](https://github.com/udacity/AIPND/blob/master/notes/lab_intro-to-python-lab.md#running-batch-files-on-windows-os-locally).  \n\nOnce you have ran all three models using ```run_models_batch.sh``` (```run_models_batch.bat```  on Windows) compare your results with those you will find in the section **Final Results**.\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 665080,
          "key": "cc05c681-fb6e-488f-8c21-4a99b1f5c8c1",
          "title": "Project Workspace - Printing Results",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "cc05c681-fb6e-488f-8c21-4a99b1f5c8c1",
            "completed_at": "2020-04-16T04:39:04.539Z",
            "last_viewed_at": "2020-04-16T05:24:29.931Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 665084,
              "key": "d1c6c892-424a-4cf7-8d82-0a1decb7d797",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "view77231794",
              "pool_id": "webterminal",
              "view_id": "4034e111-3a98-42f3-8bae-ac242c315b06",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "userCode": "",
                    "openFiles": [
                      "/home/workspace/print_results.py",
                      "/home/workspace/print_results_hints.py"
                    ],
                    "showFiles": true,
                    "allowClose": true,
                    "allowSubmit": false
                  },
                  "kind": "generic"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 665474,
          "key": "81213de9-ad01-44a6-bff6-5b73e4adfc57",
          "title": "Classify Uploaded Images",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "81213de9-ad01-44a6-bff6-5b73e4adfc57",
            "completed_at": "2020-04-16T05:24:39.486Z",
            "last_viewed_at": "2020-04-16T06:03:35.946Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 665482,
              "key": "db5e507a-0f45-44e5-9b49-d8d7035457ab",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Classify Uploaded Images\n\n## Classifying Uploaded Images \nThis section will help you test your program by classifying your own images. \n\nYour ***check_images.py*** program should now  successfully classify the 40 images from the *pet_images* folder. In this section you will upload 4 images to the *uploaded_images* folder, then run the file ***run_models_batch_uploaded.sh*** to classify those 4 images.  \n \n### Directions for Finding Images and Uploading Images\nBelow are directions for finding images and processing them so they can be classified by the ***check_images.py*** program.\n- Process the images so that: \n  - Images are in jpeg format with extension *jpg*\n  - Images are approximately square in shape (their height and width are approximately the same number of pixels). \n- Find the following **3** images (or take the following 3 pictures):\n - **_Dog_ Image** - named *Dog_01.jpg*. Make sure you know the *breed* of dog that the image is of. \n - **_Pet_ or _Animal_ Image** that's *not* a dog - named *Animal_Name_01.jpg *, where *Animal_Name* is the name of the animal in the picture. This name is formatted such that if more than one word makes up the *animal name* those words are separated by an underbar ( _ ). \n   - For example:\n     - Image of a *Black Bear* is named *Black_bear_01.jpg*\n     - Image of a *Frog* is named *Frog_01.jpg*\n - An **image of something** that's *not* an animal - named *Object_Name_01.jpg*, where *Object_Name* is the name of the object in the picture. This name is formatted such that if more than one word makes up the *object name* those words are separated by an underbar ( _ ). \n   - For example:\n     - Image of a *Coffee Mug* is named *Coffee_mug_01.jpg*\n     - Image of a *Bucket* is named *Bucket_01.jpg*\n\n- Create a fourth Image of a Dog using *Dog_01.jpg*\n  - Using *Dog_01.jpg* image horizontally flip the image and name it *Dog_02*.jpg. This will mean that *Dog_02*.jpg is a mirror image of *Dog_01*.jpg. If you are having difficulty with the *horizontal* flip alteration of *Dog_01.jpg*, just rotate *Dog_01.jpg* image by 180 degrees so that *Dog_02*.jpg is an upside down version of *Dog_01*.jpg.\n\n",
              "instructor_notes": ""
            },
            {
              "id": 680172,
              "key": "f0882d3f-5745-495a-bf2d-c2645b69f6e6",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "##### Upload all four images to the *uploaded_images* folder within the **Project Workspace - Uploaded **\n - Double click on the *uploaded_images* folder within the **Project Workspace - Uploaded **.\n - Next, click on the white **+** symbol above */>home>workspace>uploaded_images* text \n - Next, select **Upload File** from the dropdown menu\n - Next, select one of the four files to upload to the *uploaded_images* folder and click on the *Open* button\n - Repeat the same process to upload the rest of the four files to the *uploaded_images* folder\n - To return to the *workspace* folder:\n   -  Click on the white **<** symbol above */>home>workspace>uploaded_images* text \n\n### Directions for Running ***check_images.py*** using all 3 Model Architectures\n\nNow that you have completed coding check_images.py, you are ready to run it on all 3 models to classify the four images in the *uploaded_images* folder. To do this you will be calling the following shell script that will output the following results files:\n- resnet_uploaded-images.txt - that contains the results using CNN model architecture ResNet\n- alexnet_uploaded-images.txt - that contains the results using CNN model architecture AlexNet\n- vgg_uploaded-images.txt - that contains the results using CNN model architecture VGG\n\nTo run file **run_models_batch_uploaded.sh** in the workspace, open a terminal window within the **Project Workspace - Uploaded Images** and type the following, then hit enter:   \n```terminal\nsh run_models_batch_uploaded.sh\n```\nThis will run ***check_images.py*** using all three model architectures to classify the four images in *uploaded_images* folder outputting their results files into the *workspace*.\n",
              "instructor_notes": ""
            },
            {
              "id": 665718,
              "key": "2f02decf-c2c0-4e5f-982e-8523a0c201d5",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Questions to Answer regarding Uploaded Image Classification: \nOnce the program stops running and the results files appear in the *workspace*,  open and review each of the three to answer the following questions:\n\n**1.** Did the three model architectures classify the breed of dog in *Dog_01.jpg* to be the same breed?  If not, report the differences in the classifications.    \n&nbsp;\n\n**2.** Did each of the three model architectures classify the breed of dog in *Dog_01.jpg* to be the same breed of dog as that model architecture classified *Dog_02.jpg*?  If not, report the differences in the classifications.    \n&nbsp;\n\n**3.** Did the three model architectures correctly classify *Animal_Name_01.jpg * and *Object_Name_01.jpg * to **not** be dogs? If not, report the misclassifications.   \n&nbsp;\n\n**4.** Based upon your answers for questions **1.** - **3.** above, select the model architecture that you feel did the ***best*** at classifying the four *uploaded images*. Describe *why* you selected that model architecture as the ***best*** on uploaded image classification.    \n",
              "instructor_notes": ""
            },
            {
              "id": 680173,
              "key": "57f30d4c-e187-416d-8ee9-a998f1207928",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "#### Project Workspace - Classify Uploaded Images can be found in the next concept.\n",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 665475,
          "key": "4514b8b8-b199-45a2-9688-d1c1a4ee7dc5",
          "title": "Project Workspace - Classify Uploaded Images",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "4514b8b8-b199-45a2-9688-d1c1a4ee7dc5",
            "completed_at": "2020-04-16T05:24:58.065Z",
            "last_viewed_at": "2020-04-16T06:12:47.834Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 665480,
              "key": "6d3af9d8-86b8-478f-b81a-8be0f030fe57",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "view77231794",
              "pool_id": "webterminal",
              "view_id": "2eee926f-e451-412d-8e2e-5098af3af7a6",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "userCode": "",
                    "openFiles": [
                      "/home/workspace/check_images.py"
                    ],
                    "showFiles": true,
                    "allowClose": true,
                    "allowSubmit": false
                  },
                  "kind": "generic"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        },
        {
          "id": 665081,
          "key": "c96c72c1-9d3f-4e92-92dc-e15c4c68ae20",
          "title": "Final Results",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "c96c72c1-9d3f-4e92-92dc-e15c4c68ae20",
            "completed_at": "2020-04-16T04:56:32.474Z",
            "last_viewed_at": "2020-04-16T06:13:10.989Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 665094,
              "key": "b0046563-08da-4f0d-93ca-dd504eb5f9d9",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "***\n# Results\nIn this section we \n- Provide the results from running the **check_images.py** for all *three* CNN model architectures\n- Compare these results to the ones your program produced when you ran  *run_models_batch.sh* (or *run_models_batch_hints.sh*) in the **Printing Results** section\n- Discuss how the **check_images.py** addressed the four primary objectives of this Project",
              "instructor_notes": ""
            },
            {
              "id": 665095,
              "key": "56480042-a5ab-4f63-a86f-6f407e5d8fbb",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### In this project we had 2 main objectives:\n1. Identifying which pet images are of dogs and which pet images aren't of dogs\n2. Classifying the breeds of dogs, for the images that are of dogs  \n\n\nYour program should have provided you with objectives *1* and *2* when it was run.  In the table below, you will find our results for each of the model architectures. Your program should provide you with the same results as we have provided below.\n\n- For objective 1, notice that both *VGG* and *AlexNet* correctly identify images of \"dogs\" and \"not-a-dog\" 100% of the time.  \n- For objective 2, *VGG* provides the best solution because it classifies the correct breed of dog over 90% of the time.\n\n  \n",
              "instructor_notes": ""
            },
            {
              "id": 680184,
              "key": "040a6f62-3fe0-4de6-9960-98a9d082f964",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Results Table",
              "instructor_notes": ""
            },
            {
              "id": 665097,
              "key": "7abb3ec2-7fc1-416c-87e7-d0ae71c3c92d",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2018/March/5aa84e54_aipnd-intropythonlab-results/aipnd-intropythonlab-results.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/7abb3ec2-7fc1-416c-87e7-d0ae71c3c92d",
              "caption": "** Project Results **",
              "alt": "",
              "width": 645,
              "height": 240,
              "instructor_notes": null
            },
            {
              "id": 665096,
              "key": "a4da237c-5ef1-45cc-81e0-f52052f30098",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\nGiven our results, the \"**best**\" model architecture is ***VGG***.  It out performed both of the other architectures when considering both objectives *1* and *2*.  You will notice that *ResNet* did classify dog breeds better than *AlexNet*, but only *VGG* and *AlexNet* were able to classify \"dogs\" and \"not-a-dog\" at 100% accuracy.  The model *VGG* was the one that was able to classify \"dogs\" and \"not-a-dog\" with 100% accuracy and had the best performance regarding breed classification with 93.3% accuracy.\n\n",
              "instructor_notes": ""
            },
            {
              "id": 680185,
              "key": "f240ff89-984e-48f5-8335-3cb82e2c321d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "**Use the next (last!) workspace to present and print your final results. You can use the table above as a reference**.\n ",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 665082,
          "key": "86214245-1f62-46fa-b6f3-39b1eb9e948f",
          "title": "Project Workspace - Final Results",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "86214245-1f62-46fa-b6f3-39b1eb9e948f",
            "completed_at": "2020-04-16T04:56:20.122Z",
            "last_viewed_at": "2020-04-17T06:45:45.046Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 665083,
              "key": "74ae0a5c-ad01-4633-a08c-d29d74afc03a",
              "title": null,
              "semantic_type": "WorkspaceAtom",
              "is_public": true,
              "workspace_id": "view77231794",
              "pool_id": "webterminal",
              "view_id": "5ea35929-79f8-49e1-8ffc-3c018cd7bd64",
              "gpu_capable": false,
              "configuration": {
                "id": "reserved",
                "blueprint": {
                  "conf": {
                    "disk": null,
                    "port": 3000,
                    "ports": [],
                    "userCode": "",
                    "openFiles": [
                      "/home/workspace/check_images.py"
                    ],
                    "showFiles": true,
                    "allowClose": true,
                    "allowSubmit": true
                  },
                  "kind": "generic"
                },
                "workspaceId": "reserved"
              },
              "starter_files": null
            }
          ]
        }
      ]
    }
  },
  "_deprecated": [
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    }
  ]
}